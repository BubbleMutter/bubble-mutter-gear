[TOC]
garbage collection
将不再使用或者没有任何指针再指向的内存空间
收集起来以便再次利用的机制, 称为"垃圾回收"

# 垃圾回收方法分类
## 引用计数法 (reference counting garbage collector)
采用某种机制, 记录对象被引用的次数,
当对象引用次数变为0, 改对象即可视为"垃圾", 等待后续回收
优点: 实现简单, 副作用小(不会造成 程序卡顿, 不会影响系统的缓存和交换空间)
缺点: 难以处理"环形引用"问题, 计数带来额外开销
## 跟踪处理法 (tracing garbage collector)
跟踪处理"对象关系图", 然后进行垃圾回收
### 标记-清除法 (Mark-Sweep)
1. "根对象" 正在使用的对象
2. "活对象" 被标记的对象  (活对象 Live Object) (可达对象 Reachable Object)
3. 标记流程: 从"根对象"开始递归式查找其所引用对象的堆空间, 并打上标记
4. 清除流程: 清除没有被标记的对象
5. 优点: 不移动对象
6. 缺点: 碎片化问题严重

### 标记-整理法 (Mark-Compact)
1. 在"标记-清除法"的基础上, 标记流程后
2. 整理流程: 把"活对象"左移, 覆盖没被标记对象的空间, 解决内存碎片问题
3. 优点: 没有内存碎片化
4. 缺点: 需要更新上下文的"活对象"引用

### 标记-拷贝法 (Mark-Copy)
1. 把堆内存拆分成 ping-pang 两个部分
   在"标记-清除法"的基础上, 标记流程后
2. 拷贝流程: 把"活对象"全部移动到另一部分
3. 优点: 没有内存碎片化
4. 缺点: 需要更新上下文的"活对象"引用
         导致堆内存利用率降低