[TOC]
# Hash
+ hash 扩容的过程
+ hash 和 array 的优缺点比较
+ hash 用链表解决冲突时, 还是冲突怎么办? 扩容
+ 为什么 bucket 个数是2的次方大小时，hash的效率最高
+ resources
    + java HashMap  https://zhuanlan.zhihu.com/p/151027796
    + hash 入门讲解 https://zhuanlan.zhihu.com/p/144296454

# Hash Function
+ 直接定址法 (线性函数) = `H(key) = a * key + b (其中a, b可以为 0)`
+ 除留余数法 (质数取模) = `H(key) = key % p (其中 p ≤ m)`
+ 平方取中法
    + 关键字值的平方，然后取平方值中间几位作为散列地址
    + 取的位数由表长决定
+ 折叠法 = 将关键字分为位数相同的几部分，然后取这几部分的叠加和（舍去进位）作为散列地址。

# Hash Conflict
## 2.1 拉链法
1. 优点
    1. 插入快速; 无堆积(非key不会发生冲突) 因此平均查找长度较短
    2. 各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况
    3. 在用拉链法构造的散列表中，删除结点的操作易于实现
2. 缺点
    1.
## 2.2 开放地址法
1. 位桶不需要链表来实现 装载因子不会超过1
2. 它的实现是在插入一个元素，先通过哈希函数进行判断，
3. 若是发生哈希冲突，就以当前地址为基准，根据再寻址的方法（探查序列），去寻找下一个地址
4. 若发生冲突再去寻找，直至找到一个为空的地址为止

### 2.2.1 线性探测LP
1. ` hi = ( h(key) + i ) ％ m    其中 (0 ≤ i ≤ m-1)`
2. 基本思想:
    1. 探查时从地址 d `(h(key))` 开始
    2. 首先探查 T[d]，然后依次探查 T[d+1]，…，直到 T[m-1]
    3. 此后又循环到 T[0] T[1] ...
    4. 直到探查到 有空余地址 或者到 T[d-1]为止

### 2.2.2 二次探测QP
1. ` hi = ( h(key) + i*i ) ％ m  其中 (0 ≤ i ≤ m-1)`
2. 基本思想：
    1. 探查时从地址 d `(h(key))` 开始
    2. 首先探查 T[d]，然后依次探查 T[d+1^2] T[d+2^2] T[d+3^2] ...
    3. 直到探查到 有空余地址 或者到 T[d-1]为止
3. 缺点是无法探查到整个散列空间

### 2.2.3 双倍散列DP
1. `hi=( h(key) + i*h1(key) ) ％ m，其中 (0 ≤ i ≤ m-1)`
2. 基本思想
    1. 探查时从地址 d ( h(key)) 开始
    2. 首先探查 T[d]，然后依次探查 `T[d+h1(d)]` `T[d + 2*h1(d)]` ...
3. 该方法使用了两个散列函数 h(key) 和 h1(key)，故也称为双散列函数探查法。
4. Note: 必须使 h1(key) 的值和 m 互素，才能使发生冲突的同义词地址均匀地分布在整个表中，否则可能造成同义词地址的循环计算。
5. Note: 该方法是开放定址法中最好的方法之一

## 2.3 再散列法

## 2.4 公共溢出区